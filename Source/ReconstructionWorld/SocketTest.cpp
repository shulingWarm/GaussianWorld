// Fill out your copyright notice in the Description page of Project Settings.


#include "SocketTest.h"
#include "Sockets.h"
#include "IImageWrapper.h"
#include "IImageWrapperModule.h"
#include "Runtime/Core/Public/Misc/FileHelper.h"
#include "MessageManager.hpp"
#include"AdvCommunicate.hpp"
#include "HelloMessage.hpp"
#include "MessageRunner.hpp"
#include"ImageMessage.hpp"
#include"ImageReceiveMessage.hpp"
#include"ImageEndMessage.hpp"
#include"ImageRowDataMessage.hpp"
#include"HunyuanMeshGenMessage.hpp"
#include"MeshMessage.hpp"
#include"VertexArrayBack.hpp"
#include"RequestMeshVertices.hpp"
#include"VertexFinishMessage.hpp"
#include"MeshTestMessage.hpp"
#include"RequestFaceMessage.hpp"
#include"FaceArrayBack.hpp"
#include"FaceFinishMessage.hpp"
#include"LongArrayMessage.hpp"
#include"LongArrayBackMessage.hpp"
#include"RequestLongArrayMessage.hpp"
#include"UvVertexFinishMessage.hpp"
#include"RequestTextureMessage.hpp"
#include"TextureFinishMessage.hpp"
#include"ImagePackageInfo.hpp"
#include"RequestFaceUvMessage.hpp"
#include"FaceUvFinishMessage.hpp"
#include"MeshFinishFunctor.hpp"
#include"ImageCommLib.hpp"
#include"ReconstructionCommLib.hpp"
#include"ReconstructionMessage.hpp"
#include"ReconstructionPackage.hpp"
#include"ReconSingleFileImg.hpp"
#include"ReconSingleImgMsg.hpp"
#include"ReconRecvMsg.hpp"
#include"ReconBeginMsg.hpp"
#include"ReconResultMsg.hpp"
#include"FilePathGenSource.hpp"

#include"ArrayImage.hpp"
#include"ImageList.hpp"

#include "Internationalization/Text.h"
#include "Misc/OutputDevice.h"
#include "Internationalization/Internationalization.h"
#include "Common/TcpSocketBuilder.h"

// Sets default values
ASocketTest::ASocketTest()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}

// Called when the game starts or when spawned
void ASocketTest::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void ASocketTest::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

UTexture2D* ASocketTest::buildFromMeshQueue(UDynamicMesh* mesh)
{
	//UE_LOG(LogTemp, Warning, TEXT("buildFromMeshQueue"));
	//Ptr<MeshSolver> ueMesh;
	//if (this->meshTaskQueue.Dequeue(ueMesh)) {
	//	// 调用generator生成mesh
	//	ueMesh->buildUeMesh(mesh);
	//	// 从mesh solver里面获取ue texture
	//	UTexture2D* texture = ueMesh->makeUeTexture();
	//	return texture;
	//}
	return nullptr;
}

UMeshDescriptor* ASocketTest::getMeshDescriptorFromQueue()
{
	Ptr<MeshSolver> ueMesh;
	if (this->meshTaskQueue.Dequeue(ueMesh)) {
		UMeshDescriptor* ret = NewObject<UMeshDescriptor>();
		ret->initMeshSolver(ueMesh);
		return ret;
	}
	return nullptr;
}

bool ASocketTest::judgeHaveMeshToLoad()
{
	return !this->meshTaskQueue.IsEmpty();
}

bool ASocketTest::judgeHaveSplatLoad()
{
	return !this->splatTaskQueue.IsEmpty(); 
}

void ASocketTest::testSocket()
{
	//最后得到的socket指针
	TSharedPtr<FInternetAddr> Addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();
	//IP地址
	FString ipString = "192.168.2.156";
	//端口号
	int port = 54321;
	//指定ip地址
	bool ipValid;
	Addr->SetIp(*ipString, ipValid);
	//判断是否设置成功
	if (ipValid) {
		UE_LOG(LogTemp, Warning, TEXT("ip set ok!"));
	}
	else {
		UE_LOG(LogTemp, Warning, TEXT("ip set failed!"));
	}
	//设置端口号
	Addr->SetPort(port);
	//把接收消息设置成阻塞状态
	this->socket = FTcpSocketBuilder(TEXT("TcpClient")).AsBlocking().WithReceiveBufferSize(2 * 1024 * 1024);
	//用socket连接指定地址
	bool connected = this->socket->Connect(*Addr);
	if (connected) {
		UE_LOG(LogTemp, Warning, TEXT("Connect ok!"));
	}
	else {
		UE_LOG(LogTemp, Warning, TEXT("Connect failed!"));
	}
}

void ASocketTest::sendData()
{
	if (!this->socket)
	{
		UE_LOG(LogTemp, Log, TEXT("Socket is not connected!"));
		return;
	}

	// 发送数据部分
	int32 SentBytes = 0;
	char message[] = "Hello from UE";
	uint32 dataSize = strlen(message);
 	bool bSuccess = this->socket->Send((uint8*)message, dataSize, SentBytes);

	if (!bSuccess || SentBytes != dataSize)
	{
		UE_LOG(LogTemp, Log, TEXT("Failed to send data!"));
		return;
	}
	GEngine->AddOnScreenDebugMessage(-1, 5.0, FColor::Green, TEXT("Success to send data!"));
	UE_LOG(LogTemp, Log, TEXT("Success to send data!"));
}

void ASocketTest::receiveData()
{

	if (this->socket)
	{
		uint32 Size;
		while (socket->HasPendingData(Size))
		{
			//待接收的数据
			char recData[1024];

			int32 ReadBytes = 0;
			// 读取数据到字节流中
			socket->Recv((uint8*)recData, Size, ReadBytes);
			UE_LOG(LogTemp, Warning, TEXT("read byte: %d\n"), ReadBytes);
			UE_LOG(LogTemp, Warning, TEXT("message: %s\n"), *FString(recData));
		}
	}
}

void ASocketTest::loadImageTest()
{
	//原始文件的路径
	FString filePath = "E:/temp/test2.jpeg";
	//用于存储读取数据的数组
	TArray<uint8> RawFileData;
	//读取原始图片文件里面的数据
	if (!FFileHelper::LoadFileToArray(RawFileData, *filePath))
	{
		UE_LOG(LogTemp, Warning, TEXT("Load image file failed!"));
		return;
	}
	else {
		UE_LOG(LogTemp, Warning, TEXT("Load image ok!"));
	}
	//准备image warper里面的module
	IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>(FName("ImageWrapper"));
	//生成获取图片的warper
	auto imageWrapper = ImageWrapperModule.CreateImageWrapper(EImageFormat::JPEG);
	//把图片数据注册进image wrapper
	imageWrapper->SetCompressed(RawFileData.GetData(), RawFileData.Num());
	//从imageWrapper里面转换成BGRA数据
	//这是原始的bgra数据
	TArray<uint8> uncompressImageData;
	imageWrapper->GetRaw(ERGBFormat::RGBA, 8, uncompressImageData);
	//向Linux端发送图片
	if (!socket) {
		UE_LOG(LogTemp, Warning, TEXT("Invlaid socket"));
		return;
	}
	//正式发送数据
	int32 sentByte = 0;
	socket->Send((uint8*)uncompressImageData.GetData(), uncompressImageData.Num(), sentByte);
	//打印字节数和实际发送出去的字节数
	UE_LOG(LogTemp, Warning, TEXT("Actual: %d, Sent: %d\n"), uncompressImageData.Num(), sentByte);
	
}

void ASocketTest::sendHello()
{
	//通过已经启动的manager发送一个信息
	if (launchedManager != nullptr) {

		// 完成mesh生成后，将mesh添加到本地队列里面
		auto meshFinishFunctor = [&](Ptr<MeshSolver> mesh, uint32_t idPackage) {
			// 将mesh添加到本地队列里面
			meshTaskQueue.Enqueue(mesh);
		};

		// 新建图片
		auto image = makePtr<ArrayImage>("E:/temp/car.jpeg");
		// 新建传输图片的消息
		ImageMessage imageMessage(image, makePtr<ImageFuncEndOperation>(
			[this, meshFinishFunctor](Ptr<ImageSolver> image, uint32_t idPackage) {
				// 请求目标根据图片生成mesh
				HunyuanMeshGenMessage meshGenMessage(idPackage,
					makePtr<MeshFinishLambdaFunctor>(meshFinishFunctor));
				this->launchedManager->sendMessage(meshGenMessage);
		}));
		// 发送图片消息
		launchedManager->sendMessage(imageMessage);

		// 发送mesh测试的消息
		/*MeshTestMessage testMessage;
		launchedManager->sendMessage(testMessage);*/
	}
}

void ASocketTest::GenerateMeshFromImage(FString imgPath)
{
	// 完成mesh生成后，将mesh添加到本地队列里面
	auto meshFinishFunctor = [this, imgPath](Ptr<MeshSolver> mesh, uint32_t idPackage) {
		UE_LOG(LogTemp, Warning, TEXT("Finish mesh functor"));
		// 记录MeshGen的来源
		mesh->meshGenSource = makePtr<FilePathGenSource>(
			FormatLibrary::convertToStdString(imgPath));
		// 将mesh添加到本地队列里面
		this->meshTaskQueue.Enqueue(mesh);
	};

	// 图片发送完成时的执行逻辑
	auto imgEndOperator = makePtr<ImageFuncEndOperation>(
		[this, meshFinishFunctor](Ptr<ImageSolver> image, uint32_t idPackage) {
			// 根据图片，发送生成mesh的请求
			HunyuanMeshGenMessage meshGenMessage(idPackage,
				makePtr<MeshFinishLambdaFunctor>(meshFinishFunctor));
			this->launchedManager->sendMessage(meshGenMessage);
	});

	//通过已经启动的manager发送一个信息
	if (launchedManager != nullptr) {
		// 新建图片
		auto image = makePtr<ArrayImage>(imgPath);
		// 新建传输图片的消息
		sendImage(image,
			launchedManager, imgEndOperator);

		// 发送mesh测试的消息
		/*MeshTestMessage testMessage;
		launchedManager->sendMessage(testMessage);*/
	}
}

void ASocketTest::EditMeshByImage(UMeshDescriptor* meshDesc, FString prompt)
{
	// 从mesh描述里面获取 MeshSolver
	std::string stdImgPath = 
		meshDesc->meshSolver->meshGenSource->getImgPath();
	FString imgPath = FormatLibrary::convertToFString(stdImgPath);
	// 完成mesh生成后，将mesh添加到本地队列里面
	auto meshFinishFunctor = [this, imgPath](Ptr<MeshSolver> mesh, uint32_t idPackage) {
		UE_LOG(LogTemp, Warning, TEXT("Finish mesh functor"));
		// 记录MeshGen的来源
		mesh->meshGenSource = makePtr<FilePathGenSource>(
			FormatLibrary::convertToStdString(imgPath));
		// 将mesh添加到本地队列里面
		this->meshTaskQueue.Enqueue(mesh);
		};

	// 图片发送完成时的执行逻辑
	auto imgEndOperator = makePtr<ImageFuncEndOperation>(
		[this, meshFinishFunctor](Ptr<ImageSolver> image, uint32_t idPackage) {
			// 根据图片，发送生成mesh的请求
			HunyuanMeshGenMessage meshGenMessage(idPackage,
			makePtr<MeshFinishLambdaFunctor>(meshFinishFunctor));
		this->launchedManager->sendMessage(meshGenMessage);
	});

	//通过已经启动的manager发送一个信息
	if (launchedManager != nullptr) {
		// 新建图片
		auto image = makePtr<ArrayImage>(imgPath);
		// 新建传输图片的消息
		sendImage(image,
			launchedManager, imgEndOperator);

		// 发送mesh测试的消息
		/*MeshTestMessage testMessage;
		launchedManager->sendMessage(testMessage);*/
	}
}

void ASocketTest::sendReconRequest(FString imgFolder)
{
	// 处理重建完成的回调
	// 里面的具体内容后面再实现
	auto reconFinishFunctor = makePtr<ReconstructionFinishLambda>(
		[this](Ptr<GaussianSplatSolver> gsSplat) {
			UE_LOG(LogTemp, Warning, TEXT("Saving Gaussian splat to queue"));
			// 在本地队列里面记录这些内容
			this->splatTaskQueue.Enqueue(gsSplat);
	});
	// 发送重建请求的消息
	requestReconstruction(FormatLibrary::convertToStdString(imgFolder),
		reconFinishFunctor, this->launchedManager, this->launchedManager->streamInterface);
}

void ASocketTest::launchMessageManager()
{
	// 如果manager已经启动，就直接退出
	if (this->launchedManager != nullptr) {
		return;
	}
	//新建一个通信接口
	auto commPtr = new AdvCommunication();
	//与服务端建立连接
	commPtr->connect("192.168.2.156", 23456);
	//新建一个manager
	auto manager = new MessageManager(commPtr);
	// 给manager里面注册信息
	manager->registerMessage(new HelloMessage());
	manager->registerMessage(new ImageMessage(nullptr, nullptr));
	manager->registerMessage(new ImageReceiveMessage());
	manager->registerMessage(new ImageEndMessage(0,0,0,0));
	manager->registerMessage(new ImageRowData(nullptr, 0, 0, 0));
	manager->registerMessage(new HunyuanMeshGenMessage(0, nullptr));
	manager->registerMessage(new MeshMessage());
	manager->registerMessage(new VertexArrayBack());
	manager->registerMessage(new VertexFinishMessage());
	manager->registerMessage(new RequestMeshVertices(0,0));
	manager->registerMessage(new MeshTestMessage());
	manager->registerMessage(new RequestFaceMessage(0,0));
	manager->registerMessage(new FaceArrayBack());
	manager->registerMessage(new FaceFinishMessage());
	manager->registerMessage(new LongArrayMessage());
	manager->registerMessage(new RequestLongArrayMessage(
		LongArrayBackMessage::messageSend));
	manager->registerMessage(new LongArrayBackMessage(0,0));
	manager->registerMessage(new UvVertexFinishMessage());
	manager->registerMessage(new RequestTextureMessage(0));
	manager->registerMessage(new TextureFinishMessage());
	manager->registerMessage(new RequestFaceUvMessage(0));
	manager->registerMessage(new FaceUvFinishMessage());
	manager->registerMessage(new ReconstructionMessage(0));
	manager->registerMessage(new ReconRecvMsg());
	manager->registerMessage(new ReconBeginMsg(0));
	manager->registerMessage(new ReconResultMsg());
	manager->registerMessage(new ReconSingleFileImg(0,0,0));
	manager->registerMessage(new ReconSingleImgMsg(0, 0));
	
	
	// 新建一个主循环的执行器
	MessageRunner* runner = new MessageRunner(manager);
	// 开始执行线程
	FRunnableThread* tempThread = FRunnableThread::Create(runner, TEXT("Message thread"));
	this->launchedManager = manager;
}

UTexture2D* ASocketTest::loadMeshFromFile(UDynamicMesh* mesh)
{
	// 加载的mesh文件
	std::string meshFile = "E:/temp/ue_mesh.bin";
	// 初始化一个mesh
	auto ueMesh = UEMeshSolver::create();
	ueMesh->loadFromFile(meshFile);
	// 调用generator生成mesh
	ueMesh->buildUeMesh(mesh);
	// 从mesh solver里面获取ue texture
	UTexture2D* texture = ueMesh->makeUeTexture();
	return texture;
}

void ASocketTest::loadGsSplatToScene(UGaussianDescriptor* descriptor)
{
	// 取出第一个gaussian splatting的文件
	Ptr<GaussianSplatSolver> gsSplat;
	if (splatTaskQueue.Dequeue(gsSplat)) {
		// 调用solver里面的填充3D Gaussian数据的逻辑
		gsSplat->fillGsScene(descriptor);
	}
	else {
		throw std::runtime_error("Read Gaussian Splat Queue failed");
	}
}

